## 代码与概念的映射

## 使用场景
需求1 ：在调用Test1Service.sayHello()前完成日志记录 -> 前置通知
需求2 ：在调用Test1Service.sayHello()后完成资源关闭 -> 后置通知
需求3 ：在进入Test1Service.sayHello()后执行定义的代码 -> 环绕通知
需求4 : 当目标方法抛出异常时使用自己定义的方式来抛出  -> 异常通知
需求5 ：只希望在调用sayHello()时，来进行前置通知出来-->引入通知（自定义切入点）

## AOP代理方式
spring有两种代理方式：
      1.若目标对象实现了若干接口，spring使用JDK的
         java.lang.reflect.Proxy类代理。该类让spring动态产生
         一个新类，它实现了所需的接口，织入了通知，并且代理对
         目标对象的所有请求。
      2.若目标对象没有实现任何接口，spring使用
         CGLIB库生成目标对象的子类。使用该方式时需要注意:
          1.对接口创建代理优于对类创建代理，因为会产生更加松耦合的系统。
             对类代理是让遗留系统或无法实现接口的第三方类库同样可以得到通知，
            这种方式应该是备用方案。
          2.标记为final的方法不能够被通知。spring是为目标类产生子类。任何需要
             被通知的方法都被复写，将通知织入。final方法是不允许重写的。

